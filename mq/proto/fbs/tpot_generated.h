// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_TPOT_LIBTBAG_PROTO_FBS_TPOT_H_
#define FLATBUFFERS_GENERATED_TPOT_LIBTBAG_PROTO_FBS_TPOT_H_

#include "flatbuffers/flatbuffers.h"

namespace libtbag {
namespace proto {
namespace fbs {
namespace tpot {

struct Version;

struct Pair;

struct ProcessInfo;

struct Header;

struct VersionRequest;

struct VersionResponse;

struct EchoRequest;

struct EchoResponse;

struct LoginRequest;

struct LoginResponse;

struct LogoutRequest;

struct LogoutResponse;

struct ExecRequest;

struct ExecResponse;

struct ProcessListRequest;

struct ProcessListResponse;

struct ProcessKillRequest;

struct ProcessKillResponse;

struct ProcessRemoveRequest;

struct ProcessRemoveResponse;

struct TpotPacket;

enum ResultCode {
  ResultCode_SUCCESS = 0,
  ResultCode_UNKNOWN_ERROR = 1,
  ResultCode_EXECUTE_ERROR = 2,
  ResultCode_NOT_EXISTS = 3,
  ResultCode_KILL_ERROR = 4,
  ResultCode_RC_REMOVE_ERROR = 5,
  ResultCode_MIN = ResultCode_SUCCESS,
  ResultCode_MAX = ResultCode_RC_REMOVE_ERROR
};

inline const ResultCode (&EnumValuesResultCode())[6] {
  static const ResultCode values[] = {
    ResultCode_SUCCESS,
    ResultCode_UNKNOWN_ERROR,
    ResultCode_EXECUTE_ERROR,
    ResultCode_NOT_EXISTS,
    ResultCode_KILL_ERROR,
    ResultCode_RC_REMOVE_ERROR
  };
  return values;
}

inline const char * const *EnumNamesResultCode() {
  static const char * const names[] = {
    "SUCCESS",
    "UNKNOWN_ERROR",
    "EXECUTE_ERROR",
    "NOT_EXISTS",
    "KILL_ERROR",
    "RC_REMOVE_ERROR",
    nullptr
  };
  return names;
}

inline const char *EnumNameResultCode(ResultCode e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesResultCode()[index];
}

enum AnyPacket {
  AnyPacket_NONE = 0,
  AnyPacket_VersionRequest = 1,
  AnyPacket_VersionResponse = 2,
  AnyPacket_EchoRequest = 3,
  AnyPacket_EchoResponse = 4,
  AnyPacket_LoginRequest = 5,
  AnyPacket_LoginResponse = 6,
  AnyPacket_LogoutRequest = 7,
  AnyPacket_LogoutResponse = 8,
  AnyPacket_ExecRequest = 9,
  AnyPacket_ExecResponse = 10,
  AnyPacket_ProcessListRequest = 11,
  AnyPacket_ProcessListResponse = 12,
  AnyPacket_ProcessKillRequest = 13,
  AnyPacket_ProcessKillResponse = 14,
  AnyPacket_ProcessRemoveRequest = 15,
  AnyPacket_ProcessRemoveResponse = 16,
  AnyPacket_MIN = AnyPacket_NONE,
  AnyPacket_MAX = AnyPacket_ProcessRemoveResponse
};

inline const AnyPacket (&EnumValuesAnyPacket())[17] {
  static const AnyPacket values[] = {
    AnyPacket_NONE,
    AnyPacket_VersionRequest,
    AnyPacket_VersionResponse,
    AnyPacket_EchoRequest,
    AnyPacket_EchoResponse,
    AnyPacket_LoginRequest,
    AnyPacket_LoginResponse,
    AnyPacket_LogoutRequest,
    AnyPacket_LogoutResponse,
    AnyPacket_ExecRequest,
    AnyPacket_ExecResponse,
    AnyPacket_ProcessListRequest,
    AnyPacket_ProcessListResponse,
    AnyPacket_ProcessKillRequest,
    AnyPacket_ProcessKillResponse,
    AnyPacket_ProcessRemoveRequest,
    AnyPacket_ProcessRemoveResponse
  };
  return values;
}

inline const char * const *EnumNamesAnyPacket() {
  static const char * const names[] = {
    "NONE",
    "VersionRequest",
    "VersionResponse",
    "EchoRequest",
    "EchoResponse",
    "LoginRequest",
    "LoginResponse",
    "LogoutRequest",
    "LogoutResponse",
    "ExecRequest",
    "ExecResponse",
    "ProcessListRequest",
    "ProcessListResponse",
    "ProcessKillRequest",
    "ProcessKillResponse",
    "ProcessRemoveRequest",
    "ProcessRemoveResponse",
    nullptr
  };
  return names;
}

inline const char *EnumNameAnyPacket(AnyPacket e) {
  const size_t index = static_cast<int>(e);
  return EnumNamesAnyPacket()[index];
}

template<typename T> struct AnyPacketTraits {
  static const AnyPacket enum_value = AnyPacket_NONE;
};

template<> struct AnyPacketTraits<VersionRequest> {
  static const AnyPacket enum_value = AnyPacket_VersionRequest;
};

template<> struct AnyPacketTraits<VersionResponse> {
  static const AnyPacket enum_value = AnyPacket_VersionResponse;
};

template<> struct AnyPacketTraits<EchoRequest> {
  static const AnyPacket enum_value = AnyPacket_EchoRequest;
};

template<> struct AnyPacketTraits<EchoResponse> {
  static const AnyPacket enum_value = AnyPacket_EchoResponse;
};

template<> struct AnyPacketTraits<LoginRequest> {
  static const AnyPacket enum_value = AnyPacket_LoginRequest;
};

template<> struct AnyPacketTraits<LoginResponse> {
  static const AnyPacket enum_value = AnyPacket_LoginResponse;
};

template<> struct AnyPacketTraits<LogoutRequest> {
  static const AnyPacket enum_value = AnyPacket_LogoutRequest;
};

template<> struct AnyPacketTraits<LogoutResponse> {
  static const AnyPacket enum_value = AnyPacket_LogoutResponse;
};

template<> struct AnyPacketTraits<ExecRequest> {
  static const AnyPacket enum_value = AnyPacket_ExecRequest;
};

template<> struct AnyPacketTraits<ExecResponse> {
  static const AnyPacket enum_value = AnyPacket_ExecResponse;
};

template<> struct AnyPacketTraits<ProcessListRequest> {
  static const AnyPacket enum_value = AnyPacket_ProcessListRequest;
};

template<> struct AnyPacketTraits<ProcessListResponse> {
  static const AnyPacket enum_value = AnyPacket_ProcessListResponse;
};

template<> struct AnyPacketTraits<ProcessKillRequest> {
  static const AnyPacket enum_value = AnyPacket_ProcessKillRequest;
};

template<> struct AnyPacketTraits<ProcessKillResponse> {
  static const AnyPacket enum_value = AnyPacket_ProcessKillResponse;
};

template<> struct AnyPacketTraits<ProcessRemoveRequest> {
  static const AnyPacket enum_value = AnyPacket_ProcessRemoveRequest;
};

template<> struct AnyPacketTraits<ProcessRemoveResponse> {
  static const AnyPacket enum_value = AnyPacket_ProcessRemoveResponse;
};

bool VerifyAnyPacket(flatbuffers::Verifier &verifier, const void *obj, AnyPacket type);
bool VerifyAnyPacketVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

/// Tpot(libtbag) protocol version.
FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Version FLATBUFFERS_FINAL_CLASS {
 private:
  uint32_t major_ver_;
  uint32_t minor_ver_;

 public:
  Version() {
    memset(this, 0, sizeof(Version));
  }
  Version(uint32_t _major_ver, uint32_t _minor_ver)
      : major_ver_(flatbuffers::EndianScalar(_major_ver)),
        minor_ver_(flatbuffers::EndianScalar(_minor_ver)) {
  }
  uint32_t major_ver() const {
    return flatbuffers::EndianScalar(major_ver_);
  }
  uint32_t minor_ver() const {
    return flatbuffers::EndianScalar(minor_ver_);
  }
};
FLATBUFFERS_STRUCT_END(Version, 8);

struct Pair FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4,
    VT_VAL = 6
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  const flatbuffers::String *val() const {
    return GetPointer<const flatbuffers::String *>(VT_VAL);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           VerifyOffset(verifier, VT_VAL) &&
           verifier.VerifyString(val()) &&
           verifier.EndTable();
  }
};

struct PairBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(Pair::VT_KEY, key);
  }
  void add_val(flatbuffers::Offset<flatbuffers::String> val) {
    fbb_.AddOffset(Pair::VT_VAL, val);
  }
  explicit PairBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PairBuilder &operator=(const PairBuilder &);
  flatbuffers::Offset<Pair> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pair>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pair> CreatePair(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0,
    flatbuffers::Offset<flatbuffers::String> val = 0) {
  PairBuilder builder_(_fbb);
  builder_.add_val(val);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pair> CreatePairDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr,
    const char *val = nullptr) {
  return libtbag::proto::fbs::tpot::CreatePair(
      _fbb,
      key ? _fbb.CreateString(key) : 0,
      val ? _fbb.CreateString(val) : 0);
}

struct ProcessInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4,
    VT_ACTIVE = 6,
    VT_INFOS = 8
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  bool active() const {
    return GetField<uint8_t>(VT_ACTIVE, 0) != 0;
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyField<uint8_t>(verifier, VT_ACTIVE) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           verifier.EndTable();
  }
};

struct ProcessInfoBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessInfo::VT_PID, pid, 0);
  }
  void add_active(bool active) {
    fbb_.AddElement<uint8_t>(ProcessInfo::VT_ACTIVE, static_cast<uint8_t>(active), 0);
  }
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> infos) {
    fbb_.AddOffset(ProcessInfo::VT_INFOS, infos);
  }
  explicit ProcessInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessInfoBuilder &operator=(const ProcessInfoBuilder &);
  flatbuffers::Offset<ProcessInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessInfo> CreateProcessInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    bool active = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> infos = 0) {
  ProcessInfoBuilder builder_(_fbb);
  builder_.add_infos(infos);
  builder_.add_pid(pid);
  builder_.add_active(active);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProcessInfo> CreateProcessInfoDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    bool active = false,
    const std::vector<flatbuffers::Offset<Pair>> *infos = nullptr) {
  return libtbag::proto::fbs::tpot::CreateProcessInfo(
      _fbb,
      pid,
      active,
      infos ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*infos) : 0);
}

struct Header FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_CODE = 6,
    VT_INFOS = 8
  };
  uint64_t id() const {
    return GetField<uint64_t>(VT_ID, 0);
  }
  ResultCode code() const {
    return static_cast<ResultCode>(GetField<int32_t>(VT_CODE, 0));
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *infos() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_INFOS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ID) &&
           VerifyField<int32_t>(verifier, VT_CODE) &&
           VerifyOffset(verifier, VT_INFOS) &&
           verifier.VerifyVector(infos()) &&
           verifier.VerifyVectorOfTables(infos()) &&
           verifier.EndTable();
  }
};

struct HeaderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(uint64_t id) {
    fbb_.AddElement<uint64_t>(Header::VT_ID, id, 0);
  }
  void add_code(ResultCode code) {
    fbb_.AddElement<int32_t>(Header::VT_CODE, static_cast<int32_t>(code), 0);
  }
  void add_infos(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> infos) {
    fbb_.AddOffset(Header::VT_INFOS, infos);
  }
  explicit HeaderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HeaderBuilder &operator=(const HeaderBuilder &);
  flatbuffers::Offset<Header> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Header>(end);
    return o;
  }
};

inline flatbuffers::Offset<Header> CreateHeader(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ResultCode code = ResultCode_SUCCESS,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> infos = 0) {
  HeaderBuilder builder_(_fbb);
  builder_.add_id(id);
  builder_.add_infos(infos);
  builder_.add_code(code);
  return builder_.Finish();
}

inline flatbuffers::Offset<Header> CreateHeaderDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t id = 0,
    ResultCode code = ResultCode_SUCCESS,
    const std::vector<flatbuffers::Offset<Pair>> *infos = nullptr) {
  return libtbag::proto::fbs::tpot::CreateHeader(
      _fbb,
      id,
      code,
      infos ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*infos) : 0);
}

struct VersionRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct VersionRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit VersionRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VersionRequestBuilder &operator=(const VersionRequestBuilder &);
  flatbuffers::Offset<VersionRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VersionRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<VersionRequest> CreateVersionRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  VersionRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct VersionResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_FEATURES = 6
  };
  const Version *version() const {
    return GetStruct<const Version *>(VT_VERSION);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Pair>> *features() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Pair>> *>(VT_FEATURES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Version>(verifier, VT_VERSION) &&
           VerifyOffset(verifier, VT_FEATURES) &&
           verifier.VerifyVector(features()) &&
           verifier.VerifyVectorOfTables(features()) &&
           verifier.EndTable();
  }
};

struct VersionResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(const Version *version) {
    fbb_.AddStruct(VersionResponse::VT_VERSION, version);
  }
  void add_features(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> features) {
    fbb_.AddOffset(VersionResponse::VT_FEATURES, features);
  }
  explicit VersionResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  VersionResponseBuilder &operator=(const VersionResponseBuilder &);
  flatbuffers::Offset<VersionResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<VersionResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<VersionResponse> CreateVersionResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Version *version = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Pair>>> features = 0) {
  VersionResponseBuilder builder_(_fbb);
  builder_.add_features(features);
  builder_.add_version(version);
  return builder_.Finish();
}

inline flatbuffers::Offset<VersionResponse> CreateVersionResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Version *version = 0,
    const std::vector<flatbuffers::Offset<Pair>> *features = nullptr) {
  return libtbag::proto::fbs::tpot::CreateVersionResponse(
      _fbb,
      version,
      features ? _fbb.CreateVector<flatbuffers::Offset<Pair>>(*features) : 0);
}

struct EchoRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MSG = 4
  };
  const flatbuffers::String *msg() const {
    return GetPointer<const flatbuffers::String *>(VT_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
};

struct EchoRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg(flatbuffers::Offset<flatbuffers::String> msg) {
    fbb_.AddOffset(EchoRequest::VT_MSG, msg);
  }
  explicit EchoRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EchoRequestBuilder &operator=(const EchoRequestBuilder &);
  flatbuffers::Offset<EchoRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EchoRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<EchoRequest> CreateEchoRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> msg = 0) {
  EchoRequestBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

inline flatbuffers::Offset<EchoRequest> CreateEchoRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg = nullptr) {
  return libtbag::proto::fbs::tpot::CreateEchoRequest(
      _fbb,
      msg ? _fbb.CreateString(msg) : 0);
}

struct EchoResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_MSG = 4
  };
  const flatbuffers::String *msg() const {
    return GetPointer<const flatbuffers::String *>(VT_MSG);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MSG) &&
           verifier.VerifyString(msg()) &&
           verifier.EndTable();
  }
};

struct EchoResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_msg(flatbuffers::Offset<flatbuffers::String> msg) {
    fbb_.AddOffset(EchoResponse::VT_MSG, msg);
  }
  explicit EchoResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EchoResponseBuilder &operator=(const EchoResponseBuilder &);
  flatbuffers::Offset<EchoResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EchoResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EchoResponse> CreateEchoResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> msg = 0) {
  EchoResponseBuilder builder_(_fbb);
  builder_.add_msg(msg);
  return builder_.Finish();
}

inline flatbuffers::Offset<EchoResponse> CreateEchoResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *msg = nullptr) {
  return libtbag::proto::fbs::tpot::CreateEchoResponse(
      _fbb,
      msg ? _fbb.CreateString(msg) : 0);
}

struct LoginRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ID = 4,
    VT_PW = 6
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  const flatbuffers::String *pw() const {
    return GetPointer<const flatbuffers::String *>(VT_PW);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyOffset(verifier, VT_PW) &&
           verifier.VerifyString(pw()) &&
           verifier.EndTable();
  }
};

struct LoginRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(LoginRequest::VT_ID, id);
  }
  void add_pw(flatbuffers::Offset<flatbuffers::String> pw) {
    fbb_.AddOffset(LoginRequest::VT_PW, pw);
  }
  explicit LoginRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginRequestBuilder &operator=(const LoginRequestBuilder &);
  flatbuffers::Offset<LoginRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoginRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginRequest> CreateLoginRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    flatbuffers::Offset<flatbuffers::String> pw = 0) {
  LoginRequestBuilder builder_(_fbb);
  builder_.add_pw(pw);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginRequest> CreateLoginRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    const char *pw = nullptr) {
  return libtbag::proto::fbs::tpot::CreateLoginRequest(
      _fbb,
      id ? _fbb.CreateString(id) : 0,
      pw ? _fbb.CreateString(pw) : 0);
}

struct LoginResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_KEY = 4
  };
  const flatbuffers::String *key() const {
    return GetPointer<const flatbuffers::String *>(VT_KEY);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_KEY) &&
           verifier.VerifyString(key()) &&
           verifier.EndTable();
  }
};

struct LoginResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_key(flatbuffers::Offset<flatbuffers::String> key) {
    fbb_.AddOffset(LoginResponse::VT_KEY, key);
  }
  explicit LoginResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoginResponseBuilder &operator=(const LoginResponseBuilder &);
  flatbuffers::Offset<LoginResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LoginResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LoginResponse> CreateLoginResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> key = 0) {
  LoginResponseBuilder builder_(_fbb);
  builder_.add_key(key);
  return builder_.Finish();
}

inline flatbuffers::Offset<LoginResponse> CreateLoginResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *key = nullptr) {
  return libtbag::proto::fbs::tpot::CreateLoginResponse(
      _fbb,
      key ? _fbb.CreateString(key) : 0);
}

struct LogoutRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogoutRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogoutRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogoutRequestBuilder &operator=(const LogoutRequestBuilder &);
  flatbuffers::Offset<LogoutRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogoutRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogoutRequest> CreateLogoutRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogoutRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogoutResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogoutResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogoutResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogoutResponseBuilder &operator=(const LogoutResponseBuilder &);
  flatbuffers::Offset<LogoutResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogoutResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogoutResponse> CreateLogoutResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogoutResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ExecRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILE = 4,
    VT_ARGS = 6,
    VT_ENVS = 8,
    VT_CWD = 10,
    VT_INPUT = 12
  };
  const flatbuffers::String *file() const {
    return GetPointer<const flatbuffers::String *>(VT_FILE);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *args() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ARGS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *envs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>> *>(VT_ENVS);
  }
  const flatbuffers::String *cwd() const {
    return GetPointer<const flatbuffers::String *>(VT_CWD);
  }
  const flatbuffers::String *input() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_FILE) &&
           verifier.VerifyString(file()) &&
           VerifyOffset(verifier, VT_ARGS) &&
           verifier.VerifyVector(args()) &&
           verifier.VerifyVectorOfStrings(args()) &&
           VerifyOffset(verifier, VT_ENVS) &&
           verifier.VerifyVector(envs()) &&
           verifier.VerifyVectorOfStrings(envs()) &&
           VerifyOffset(verifier, VT_CWD) &&
           verifier.VerifyString(cwd()) &&
           VerifyOffset(verifier, VT_INPUT) &&
           verifier.VerifyString(input()) &&
           verifier.EndTable();
  }
};

struct ExecRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_file(flatbuffers::Offset<flatbuffers::String> file) {
    fbb_.AddOffset(ExecRequest::VT_FILE, file);
  }
  void add_args(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args) {
    fbb_.AddOffset(ExecRequest::VT_ARGS, args);
  }
  void add_envs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> envs) {
    fbb_.AddOffset(ExecRequest::VT_ENVS, envs);
  }
  void add_cwd(flatbuffers::Offset<flatbuffers::String> cwd) {
    fbb_.AddOffset(ExecRequest::VT_CWD, cwd);
  }
  void add_input(flatbuffers::Offset<flatbuffers::String> input) {
    fbb_.AddOffset(ExecRequest::VT_INPUT, input);
  }
  explicit ExecRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecRequestBuilder &operator=(const ExecRequestBuilder &);
  flatbuffers::Offset<ExecRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecRequest> CreateExecRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> file = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> args = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<flatbuffers::String>>> envs = 0,
    flatbuffers::Offset<flatbuffers::String> cwd = 0,
    flatbuffers::Offset<flatbuffers::String> input = 0) {
  ExecRequestBuilder builder_(_fbb);
  builder_.add_input(input);
  builder_.add_cwd(cwd);
  builder_.add_envs(envs);
  builder_.add_args(args);
  builder_.add_file(file);
  return builder_.Finish();
}

inline flatbuffers::Offset<ExecRequest> CreateExecRequestDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *file = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *args = nullptr,
    const std::vector<flatbuffers::Offset<flatbuffers::String>> *envs = nullptr,
    const char *cwd = nullptr,
    const char *input = nullptr) {
  return libtbag::proto::fbs::tpot::CreateExecRequest(
      _fbb,
      file ? _fbb.CreateString(file) : 0,
      args ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*args) : 0,
      envs ? _fbb.CreateVector<flatbuffers::Offset<flatbuffers::String>>(*envs) : 0,
      cwd ? _fbb.CreateString(cwd) : 0,
      input ? _fbb.CreateString(input) : 0);
}

struct ExecResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           verifier.EndTable();
  }
};

struct ExecResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ExecResponse::VT_PID, pid, 0);
  }
  explicit ExecResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExecResponseBuilder &operator=(const ExecResponseBuilder &);
  flatbuffers::Offset<ExecResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExecResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExecResponse> CreateExecResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0) {
  ExecResponseBuilder builder_(_fbb);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct ProcessListRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ProcessListRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ProcessListRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessListRequestBuilder &operator=(const ProcessListRequestBuilder &);
  flatbuffers::Offset<ProcessListRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessListRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessListRequest> CreateProcessListRequest(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ProcessListRequestBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ProcessListResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PROCS = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<ProcessInfo>> *procs() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<ProcessInfo>> *>(VT_PROCS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROCS) &&
           verifier.VerifyVector(procs()) &&
           verifier.VerifyVectorOfTables(procs()) &&
           verifier.EndTable();
  }
};

struct ProcessListResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_procs(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessInfo>>> procs) {
    fbb_.AddOffset(ProcessListResponse::VT_PROCS, procs);
  }
  explicit ProcessListResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessListResponseBuilder &operator=(const ProcessListResponseBuilder &);
  flatbuffers::Offset<ProcessListResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessListResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessListResponse> CreateProcessListResponse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<ProcessInfo>>> procs = 0) {
  ProcessListResponseBuilder builder_(_fbb);
  builder_.add_procs(procs);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProcessListResponse> CreateProcessListResponseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<ProcessInfo>> *procs = nullptr) {
  return libtbag::proto::fbs::tpot::CreateProcessListResponse(
      _fbb,
      procs ? _fbb.CreateVector<flatbuffers::Offset<ProcessInfo>>(*procs) : 0);
}

struct ProcessKillRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4,
    VT_SIGNUM = 6
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  int32_t signum() const {
    return GetField<int32_t>(VT_SIGNUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           VerifyField<int32_t>(verifier, VT_SIGNUM) &&
           verifier.EndTable();
  }
};

struct ProcessKillRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessKillRequest::VT_PID, pid, 0);
  }
  void add_signum(int32_t signum) {
    fbb_.AddElement<int32_t>(ProcessKillRequest::VT_SIGNUM, signum, 0);
  }
  explicit ProcessKillRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessKillRequestBuilder &operator=(const ProcessKillRequestBuilder &);
  flatbuffers::Offset<ProcessKillRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessKillRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessKillRequest> CreateProcessKillRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0,
    int32_t signum = 0) {
  ProcessKillRequestBuilder builder_(_fbb);
  builder_.add_signum(signum);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct ProcessKillResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ProcessKillResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ProcessKillResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessKillResponseBuilder &operator=(const ProcessKillResponseBuilder &);
  flatbuffers::Offset<ProcessKillResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessKillResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessKillResponse> CreateProcessKillResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ProcessKillResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ProcessRemoveRequest FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PID = 4
  };
  int32_t pid() const {
    return GetField<int32_t>(VT_PID, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_PID) &&
           verifier.EndTable();
  }
};

struct ProcessRemoveRequestBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pid(int32_t pid) {
    fbb_.AddElement<int32_t>(ProcessRemoveRequest::VT_PID, pid, 0);
  }
  explicit ProcessRemoveRequestBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessRemoveRequestBuilder &operator=(const ProcessRemoveRequestBuilder &);
  flatbuffers::Offset<ProcessRemoveRequest> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessRemoveRequest>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessRemoveRequest> CreateProcessRemoveRequest(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pid = 0) {
  ProcessRemoveRequestBuilder builder_(_fbb);
  builder_.add_pid(pid);
  return builder_.Finish();
}

struct ProcessRemoveResponse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ProcessRemoveResponseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ProcessRemoveResponseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProcessRemoveResponseBuilder &operator=(const ProcessRemoveResponseBuilder &);
  flatbuffers::Offset<ProcessRemoveResponse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ProcessRemoveResponse>(end);
    return o;
  }
};

inline flatbuffers::Offset<ProcessRemoveResponse> CreateProcessRemoveResponse(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ProcessRemoveResponseBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TpotPacket FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_HEADER = 4,
    VT_PACKET_TYPE = 6,
    VT_PACKET = 8
  };
  const Header *header() const {
    return GetPointer<const Header *>(VT_HEADER);
  }
  AnyPacket packet_type() const {
    return static_cast<AnyPacket>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const VersionRequest *packet_as_VersionRequest() const {
    return packet_type() == AnyPacket_VersionRequest ? static_cast<const VersionRequest *>(packet()) : nullptr;
  }
  const VersionResponse *packet_as_VersionResponse() const {
    return packet_type() == AnyPacket_VersionResponse ? static_cast<const VersionResponse *>(packet()) : nullptr;
  }
  const EchoRequest *packet_as_EchoRequest() const {
    return packet_type() == AnyPacket_EchoRequest ? static_cast<const EchoRequest *>(packet()) : nullptr;
  }
  const EchoResponse *packet_as_EchoResponse() const {
    return packet_type() == AnyPacket_EchoResponse ? static_cast<const EchoResponse *>(packet()) : nullptr;
  }
  const LoginRequest *packet_as_LoginRequest() const {
    return packet_type() == AnyPacket_LoginRequest ? static_cast<const LoginRequest *>(packet()) : nullptr;
  }
  const LoginResponse *packet_as_LoginResponse() const {
    return packet_type() == AnyPacket_LoginResponse ? static_cast<const LoginResponse *>(packet()) : nullptr;
  }
  const LogoutRequest *packet_as_LogoutRequest() const {
    return packet_type() == AnyPacket_LogoutRequest ? static_cast<const LogoutRequest *>(packet()) : nullptr;
  }
  const LogoutResponse *packet_as_LogoutResponse() const {
    return packet_type() == AnyPacket_LogoutResponse ? static_cast<const LogoutResponse *>(packet()) : nullptr;
  }
  const ExecRequest *packet_as_ExecRequest() const {
    return packet_type() == AnyPacket_ExecRequest ? static_cast<const ExecRequest *>(packet()) : nullptr;
  }
  const ExecResponse *packet_as_ExecResponse() const {
    return packet_type() == AnyPacket_ExecResponse ? static_cast<const ExecResponse *>(packet()) : nullptr;
  }
  const ProcessListRequest *packet_as_ProcessListRequest() const {
    return packet_type() == AnyPacket_ProcessListRequest ? static_cast<const ProcessListRequest *>(packet()) : nullptr;
  }
  const ProcessListResponse *packet_as_ProcessListResponse() const {
    return packet_type() == AnyPacket_ProcessListResponse ? static_cast<const ProcessListResponse *>(packet()) : nullptr;
  }
  const ProcessKillRequest *packet_as_ProcessKillRequest() const {
    return packet_type() == AnyPacket_ProcessKillRequest ? static_cast<const ProcessKillRequest *>(packet()) : nullptr;
  }
  const ProcessKillResponse *packet_as_ProcessKillResponse() const {
    return packet_type() == AnyPacket_ProcessKillResponse ? static_cast<const ProcessKillResponse *>(packet()) : nullptr;
  }
  const ProcessRemoveRequest *packet_as_ProcessRemoveRequest() const {
    return packet_type() == AnyPacket_ProcessRemoveRequest ? static_cast<const ProcessRemoveRequest *>(packet()) : nullptr;
  }
  const ProcessRemoveResponse *packet_as_ProcessRemoveResponse() const {
    return packet_type() == AnyPacket_ProcessRemoveResponse ? static_cast<const ProcessRemoveResponse *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_HEADER) &&
           verifier.VerifyTable(header()) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyAnyPacket(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const VersionRequest *TpotPacket::packet_as<VersionRequest>() const {
  return packet_as_VersionRequest();
}

template<> inline const VersionResponse *TpotPacket::packet_as<VersionResponse>() const {
  return packet_as_VersionResponse();
}

template<> inline const EchoRequest *TpotPacket::packet_as<EchoRequest>() const {
  return packet_as_EchoRequest();
}

template<> inline const EchoResponse *TpotPacket::packet_as<EchoResponse>() const {
  return packet_as_EchoResponse();
}

template<> inline const LoginRequest *TpotPacket::packet_as<LoginRequest>() const {
  return packet_as_LoginRequest();
}

template<> inline const LoginResponse *TpotPacket::packet_as<LoginResponse>() const {
  return packet_as_LoginResponse();
}

template<> inline const LogoutRequest *TpotPacket::packet_as<LogoutRequest>() const {
  return packet_as_LogoutRequest();
}

template<> inline const LogoutResponse *TpotPacket::packet_as<LogoutResponse>() const {
  return packet_as_LogoutResponse();
}

template<> inline const ExecRequest *TpotPacket::packet_as<ExecRequest>() const {
  return packet_as_ExecRequest();
}

template<> inline const ExecResponse *TpotPacket::packet_as<ExecResponse>() const {
  return packet_as_ExecResponse();
}

template<> inline const ProcessListRequest *TpotPacket::packet_as<ProcessListRequest>() const {
  return packet_as_ProcessListRequest();
}

template<> inline const ProcessListResponse *TpotPacket::packet_as<ProcessListResponse>() const {
  return packet_as_ProcessListResponse();
}

template<> inline const ProcessKillRequest *TpotPacket::packet_as<ProcessKillRequest>() const {
  return packet_as_ProcessKillRequest();
}

template<> inline const ProcessKillResponse *TpotPacket::packet_as<ProcessKillResponse>() const {
  return packet_as_ProcessKillResponse();
}

template<> inline const ProcessRemoveRequest *TpotPacket::packet_as<ProcessRemoveRequest>() const {
  return packet_as_ProcessRemoveRequest();
}

template<> inline const ProcessRemoveResponse *TpotPacket::packet_as<ProcessRemoveResponse>() const {
  return packet_as_ProcessRemoveResponse();
}

struct TpotPacketBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_header(flatbuffers::Offset<Header> header) {
    fbb_.AddOffset(TpotPacket::VT_HEADER, header);
  }
  void add_packet_type(AnyPacket packet_type) {
    fbb_.AddElement<uint8_t>(TpotPacket::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(TpotPacket::VT_PACKET, packet);
  }
  explicit TpotPacketBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TpotPacketBuilder &operator=(const TpotPacketBuilder &);
  flatbuffers::Offset<TpotPacket> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TpotPacket>(end);
    return o;
  }
};

inline flatbuffers::Offset<TpotPacket> CreateTpotPacket(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Header> header = 0,
    AnyPacket packet_type = AnyPacket_NONE,
    flatbuffers::Offset<void> packet = 0) {
  TpotPacketBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_header(header);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

inline bool VerifyAnyPacket(flatbuffers::Verifier &verifier, const void *obj, AnyPacket type) {
  switch (type) {
    case AnyPacket_NONE: {
      return true;
    }
    case AnyPacket_VersionRequest: {
      auto ptr = reinterpret_cast<const VersionRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_VersionResponse: {
      auto ptr = reinterpret_cast<const VersionResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_EchoRequest: {
      auto ptr = reinterpret_cast<const EchoRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_EchoResponse: {
      auto ptr = reinterpret_cast<const EchoResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_LoginRequest: {
      auto ptr = reinterpret_cast<const LoginRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_LoginResponse: {
      auto ptr = reinterpret_cast<const LoginResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_LogoutRequest: {
      auto ptr = reinterpret_cast<const LogoutRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_LogoutResponse: {
      auto ptr = reinterpret_cast<const LogoutResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ExecRequest: {
      auto ptr = reinterpret_cast<const ExecRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ExecResponse: {
      auto ptr = reinterpret_cast<const ExecResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessListRequest: {
      auto ptr = reinterpret_cast<const ProcessListRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessListResponse: {
      auto ptr = reinterpret_cast<const ProcessListResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessKillRequest: {
      auto ptr = reinterpret_cast<const ProcessKillRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessKillResponse: {
      auto ptr = reinterpret_cast<const ProcessKillResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessRemoveRequest: {
      auto ptr = reinterpret_cast<const ProcessRemoveRequest *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case AnyPacket_ProcessRemoveResponse: {
      auto ptr = reinterpret_cast<const ProcessRemoveResponse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyAnyPacketVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyAnyPacket(
        verifier,  values->Get(i), types->GetEnum<AnyPacket>(i))) {
      return false;
    }
  }
  return true;
}

inline const libtbag::proto::fbs::tpot::TpotPacket *GetTpotPacket(const void *buf) {
  return flatbuffers::GetRoot<libtbag::proto::fbs::tpot::TpotPacket>(buf);
}

inline const libtbag::proto::fbs::tpot::TpotPacket *GetSizePrefixedTpotPacket(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<libtbag::proto::fbs::tpot::TpotPacket>(buf);
}

inline bool VerifyTpotPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<libtbag::proto::fbs::tpot::TpotPacket>(nullptr);
}

inline bool VerifySizePrefixedTpotPacketBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<libtbag::proto::fbs::tpot::TpotPacket>(nullptr);
}

inline void FinishTpotPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtbag::proto::fbs::tpot::TpotPacket> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedTpotPacketBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<libtbag::proto::fbs::tpot::TpotPacket> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace tpot
}  // namespace fbs
}  // namespace proto
}  // namespace libtbag

#endif  // FLATBUFFERS_GENERATED_TPOT_LIBTBAG_PROTO_FBS_TPOT_H_
